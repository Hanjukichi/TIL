# <b>스택2</b>
<br><br>

## <b>Ⅰ. 계산기</b>

---

### <b>ⅰ. Step1</b>
<br>

중위 표기법의 수식을 후위 표기법으로 변경(스택)  

※ 중위 표기법: A + B  
※ 후위 표기법: AB+  

#### <b>중위 표기식의 후위표기식 변환 방법1</b>  

>A*B-C/D  
>((A*B)-(C/D))  
>((AB)*-(CD)/)-   
>AB*CD/-  

#### <b>중위 표기식의 후위표기식 변환 알고리즘</b>  
1. 입력받은 중위 표기식에서 토큰 로드  
2. 토큰이 피연산자이면 토큰을 출력  
3. 토큰이 연산자(괄호 포함)일 때  
    1. 스택의 top에 저장되어 있는 연산자보다 우선순위 높음 > psuh
    2. 아닐 경우 > 커질 때까지 스택에서 pop
    3. top에 연산자가 없으면 > push
4. 토큰이 오른쪽 괄호이면 top에 왼쪽 괄호가 올 때까지 pop연산 수행
5. 왼쪽 괄호를 만나면 pop만하고 출력 X
6. 중위 표기식에 더 읽을 것이 없다면 중지
7. 스택에 남아 있는 연산자를 모두 pop하여 출력

#### <b>연산자 우선순위</b>
1|2|3|4
|---|---|---|----|
|)|* /|+ -|(|  

#### <b>알고리즘 적용 결과</b>  
>중위표기법 : ( 6 + 5 * ( 2 - 8 ) / 2 )  
후위표기법 :  
stack :  

>중위표기법 : + 5 * ( 2 - 8 ) / 2 )  
후위표기법 :  6  
stack :  (

>중위표기법 : * ( 2 - 8 ) / 2 )  
후위표기법 :  6 5  
stack :  ( +

>중위표기법 : 2 - 8 ) / 2 )  
후위표기법 :  6 5  
stack :  ( + * (

>중위표기법 : ) / 2 )  
후위표기법 :  6 5 2 8  
stack :  ( + * ( -  

>중위표기법 : / 2 )  
후위표기법 :  6 5 2 8 -  
stack :  ( + *  

>중위표기법 : 2 )  
후위표기법 :  6 5 2 8 - *  
stack :  ( + /  

>중위표기법 : )  
후위표기법 :  6 5 2 8 - * 2  
stack :  ( + /  

>중위표기법 :  
후위표기법 :  6 5 2 8 - * 2 / +  
stack :

---

### <b>ⅱ. Step2</b>
<br>

후위 표기법의 수식을 스택을 이용하여 계산

#### <b>후위 표기법 수식을 이용한 계산 알고리즘</b>  
1. 피 연산자를 만나면 스택에 push
2. 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산
3. 연산결과를 다시 스택에 push  
4. 수식이 끝나면, 마지막으로 스택을 pop하여 출력 

#### <b>알고리즘 적용 결과</b> 
>후위 표기법 : 6 5 2 8 - * 2 / +  
stack :  

>후위 표기법 : - * 2 / +  
stack : 6 5 2 8  

>후위 표기법 : * 2 / +  
stack : 6 5 -6

>후위 표기법 : 2 / +  
stack : 6 -30  

>후위 표기법 : / +  
stack : 6 -30 2

>후위 표기법 : +  
stack : 6 -15

>후위 표기법 :  
stack : -9

> 최종값 : -9

<br><br>


## <b>Ⅱ. 백트래킹</b>

---

### <b>ⅰ. 백트래킹이란?</b>
<br>

해를 찾는 도중 막히면 되돌아가서 다시 해를 찾음  

백트래킹 기법은 최적화 문제와 결정 문제를 해결 가능  
※ 결정문제: 문제의 조건을 만족하는 해가 존재하는지의 여부를 yes또는 no가 답하는 문제

---

### <b>ⅱ. 백트래킹과 깊이 우선 탐색의 차이</b>
<br>

백트래킹은 가지치기(prunning)을 통해 시도의 횟수를 줄임  

백트래킹은 불필요한 경로를 조기에 차단  

깊이 우선 탐색을 가하기에는 경우의 수가 너무 많음  

백트래킹 또한 최악의 경웅는 지수함수의 시간을 요함

---

### <b>ⅲ. 백트래킹 기법</b>
<br>

어떤 노드의 유망성을 점검한 후 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식 노드로 감  

- 유망 : 해답의 가능성이 존재
- 유망하지 않음 : 해답의 가능성이 없음
- 가지치기(prunning) : 유망하지 않는 노드를 포함하면 고려 X

---

### <b>ⅲ. 백트래킹 알고리즘</b>
<br>

상태 공간 트리의 깊이 우선 검색을 실시  

각 노드가 유망한지를 점검  

만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속

<br><br>

## <b>Ⅲ. 부분 집합, 순열</b>

---

### <b>ⅰ. 부분 집합</b>
<br>

<b>부분집합 구하기</b>
>```python
>def f(i, N):
>   if i == N:
>       for j in range(N):
>           if bit[j]:
>               print(A[j], end=' ')
>   else:
>       bit[i] = 1
>       f(i+1, N)
>       bit[i] = 0
>       f(i+1, N)
>
> A = [1,2,3]
> N = len(A)
> bit = [0]*N

지금까지의 합이 목표값보다 크면 남은 원소 고려 X

<b>합이 목표값인 부분집합의 개수 구하기 1</b>
>```python
>def f(i, N):
>   global ans
>   if i == N:
>       s = 0
>       for j in range(N):
>           if bit[j]:
>               s += A[j]
>               if s > t:
>                   break
>       else:
>           if s == t:
>               answer += 1
>   else:
>       bit[i] = 1
>       f(i+1, N)
>       bit[0] = 0
>       f(i+1, N)
>
> A = [1,2,3,4,5,6,7,8,9,10]
> N = len(A)
> bit = [0]*N
> t = 10
> ans = 0

지금까지의 합이 목표값보다 크면 남은 원소 고려 X

<b>합이 목표값인 부분집합의 개수 구하기 2</b>
>```python
># i: 원소의 순번
># N: 전체 원소 개수
># s: 현재까지의 부분집합의 합
># t: 목표값
>def f(i, N, s, t):
>   if s == t:
>       return 1
>   elif i == N:
>       return 0
>   elif s > t:    
>       return 0 
>   else:
>       return f(i+1, N, s + A[i], t) + f(i+1, N, s, t)
>   # A : 전체 집합

현재까지의 합 + 남은 구간의 합이 목표값보다 적을 경우에도 중단

---

### <b>ⅱ. 순열</b>
<br>

사전순 X
>```python
>P = [1,2,3,4]
>N = len(P)
>
>def f(i, k):
>   if i == k:
>       print(P)
>   else:    
>       for j in range(i, k):
>           P[i], P[j] = P[j], P[i]
>           f(i+1, k)
>           P[i], P[j] = P[j], P[i]  

<br><br>

## <b>Ⅲ. 분할 정복 알고리즘</b>

---

### <b>ⅰ. 설계 전략</b>
<br>

분할 : 해결할 문제를 여러 개의 작은 부분으로 나눔  

정복 : 나눈 작은 문제를 각각 해결  

통합 : 해결된 해답을 모음  

---

### <b>ⅱ. 거듭 제곱</b>
<br>

#### 보통 방법 : O(n)
C^n = C * C * C * C * C * C * C * C ...

#### 분할 정복 기반 : O(log2n)
C^n = C^(n/2) * C^(n/2)  < n이 짝수
C^n = C^((n-1)/2)* C^((n-1)/2) * C < n이 홀수

---

### <b>ⅲ. 퀵정렬</b>
<br>

주어진 배열을 두 개로 분할, 각각 정렬  

분할 할 때 기준값을 중심으로 작은 것은 왼편, 큰것은 오른편  

각 부분 정렬이 끝난 후, 퀵정렬은 합병 필요 X

>```python
>def quicksort(a, s, e):
>   if s < e:
>       p = partition(a, s, e)
>       quicksort(a, begin, p-1)
>       quicksort(a, p+1, end)
>
>def partion(a, s, e):
>   pivot = (s, e) // 2
>   L = s
>   R = end
>   while L < R:
>       while L < R and a[L] < a[pivot]:
>           L += 1
>       while L < R and a[R] >= a[pivot]:
>           R -= 1
>       if L < R:
>           if L == pivot:
>               pivot = R
>           a[L], a[R] = a[R], a[L]
>   a[pivot], a[R] = a[R], a[pivot]
>   return R    