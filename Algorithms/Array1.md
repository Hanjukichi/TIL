# <b>배열1</b>
<br><br>

## <b>Ⅰ. 알고리즘</b>

---

### <b>ⅰ. 알고리즘이란?</b>
<br>

유한한 단계를 통해 문제를 해결하기 위한 절차나 방법.  
주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법  

<b>알고리즘 표현의 종류</b>
- 의사코드(슈도코드)
- 순서도  

<b>알고리즘 평가 항목</b>
- 정학성 : 얼마나 정확하게 동작하는가
- 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
- 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
- 단순성 : 얼마나 단순한가
- 최적성 : 더 이상 개선할 여지없이 최적화되었는가

---

### <b>ⅱ. 알고리즘 성능 측적</b>
<br>

주어진 문제 해결을 위해 여러 개의 다양한 알고리즘 가능  
어떤 알고리즘 사용? - > 알고리즘의 성능 분석 필요

<b>알고리즘 평가 항목 </b>
- 정학성 : 얼마나 정확하게 동작하는가
- 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
- 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
- 단순성 : 얼마나 단순한가
- 최적성 : 더 이상 개선할 여지없이 최적화되었는가  

<b>시간 복잡도</b>
- 알고리즘의 작업량 표현이 사용
- 실제 걸리는 시간을 측정 or 실행되는 명령문의 개수 계산

<b>빅-오(O) 표기법</b>
- 시간 복잡도 함수 중 가장 큰 영향력을 주는 n에 대한 항만을 표시
- 계수는 생략하여 표시
- ex) O(3n+2) = O(n), O((2n)^2+10n) = O(n^2)  

<br><br>


## <b>Ⅱ. 배열</b>

---

### <b>ⅰ. 배열이란 무엇인가</b>
<br>

일정한 자료형의 변수들을 하나의 이름으로 열거하는 자료구조
> `Num = [01,2,3,4,5,6]`

---
### <b>ⅱ. 배열의 필요성</b>
<br>

여러 개의 변수를 지정하는건 매우 비효율적일 수 있음  

배열을 통해 하나의 선언을 통해 둘 이상의 변수 선언 가능  

다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 해결

---
### <b>ⅲ. 1차원 배열의 선언</b>
<br>

별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성  

1차원 배열의 접근
>```python
>Arr[0] = 10 # 0번 원소에 10 저장
>Arr[idx] = 20 # idx번 원소에 20 저장
>```

<br><br>


## <b>Ⅲ. 정렬</b>

---

### <b> ⅰ. 정렬이란?</b>
<br>

2개 이상의 자료를 특정 기준에 의해 재배열
- 오름차순(ascending) : 작은 값부터 큰 값
- 내림차순(descending) : 큰 값부터 작은 값

---

### <b> ⅱ. 대표적인 정렬 방식</b>
<br>

- 버블 정렬 (Bubble sort)
- 카운팅 정렬 (Counting Sort)
- 선택 정렬 (Selection Sort)
- 퀵 정렬 (Quick Sort)
- 삽입 정렬 (Insertion Sort)
- 병합 정렬 (Merge Sort)  

<br><br>



## <b>Ⅲ. 버블 정렬(Bubble Sort)</b>

---

### <b> ⅰ. 버블 정렬이란?</b>
<br>

인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식  

<b>정렬 과정</b>
- 첫 번째 원소부터 인접한 원소끼리 자리를 교환하며 맨 마지막 자리까지 이동
- 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬
- 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬  

<b>시간 복잡도</b>
- O(n^2)  

---

### <b> ⅱ. 버블 정렬 과정</b>
<br>

첫번째 패스
> |0|1|2|3|4|  
> |--|--|--|--|--|  
> |55 | 7 | 78 | 12 | 42|  
> |7 | 55 | 78 | 12 | 42| 
> |7 | 55 | 78 | 12 | 42| 
> |7 | 55 | 12 | 78 | 42| 
> |7 | 55 | 12 | 42 | 78|

두 번째 패스
> |0|1|2|3|4|  
> |--|--|--|--|--|  
> |7 | 55 | 12 | 42 | 78|
> |7 | 55 | 12 | 42 | 78|
> |7 | 12 | 55 | 42 | 78|
> |7 | 12 | 42 | 55 | 78|

세 번째 패스
> |0|1|2|3|4|  
> |--|--|--|--|--|  
> |7 | 12 | 42 | 55 | 78|
> |7 | 12 | 42 | 55 | 78|

네 번째 패스
> |0|1|2|3|4|  
> |--|--|--|--|--|  
> |7 | 12 | 42 | 55 | 78|  

---

### <b> ⅲ. 버블 정렬 알고리즘</b>
<b>슈도 코드</b>
> ```
> BubbleSor(a,N):  
>   for i : N-1 -> 1
>       for j: 0 -> i-1
>           if a[j] > a[j+1]
>               a[j] <-> a[j+1]
>```

<b>파이썬 코드</b>
> ```python
> def BubbleSor(a,N):  
>   for i in range(N-1,0,-1):
>       for j in range(0,i):
>           if a[j] > a[j+1]
>               a[j], a[j+1] = a[j+1], a[j]
>```

<br><br>



## <b>Ⅳ. 카운팅 정렬(Counting Sort)</b>

---

### <b> ⅰ. 카운팅 정렬이란?</b>
항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지  
세는 작어블 하여 선형 시간에 정렬하는 효율적인 알고리즘  

<b>제한 사항</b>
- 정수나 정수로 표현할 수있는 자료에 대해서만 적용 가능
- 카운트들을 위한 충분한 공간을 할당 > 집합 내의 가장 큰 정수를 알아야 함  

<b>시간복잡도</b>
- O(n+k): n은 리스트 길이, k는 정수의 최대값

---

### <b> ⅱ. 카운팅 정렬과정</b>
DATA
> |0|1|2|3|4|5|6|7|  
> |--|--|--|--|--|--|--|--|  
> |0|4|1|3|1|2|4|1|  

COUNTS
> |0|1|2|3|4|
> |--|--|--|--|--| 
> |1|3|1|1|2| 

COUNTS 누적합으로 원소 조정 
> |0|1|2|3|4|
> |--|--|--|--|--| 
> |1|4|5|6|8|  

올바른 위치에 숫자 집어 넣기
> ||0|1|2|3|4|5|6|7|
> |--|--|--|--|--|--|--|--|--|
> |DATA|0|4|1|3|1|2|4|| 
> |Counts|1|3|5|6|8|
> |Temp||||1|||||

> ||0|1|2|3|4|5|6|7|
> |--|--|--|--|--|--|--|--|--|
> |DATA|0|4|1|3|1|2||| 
> |Counts|1|3|5|6|7|
> |Temp||||1||||4|

> ||0|1|2|3|4|5|6|7|
> |--|--|--|--|--|--|--|--|--|
> |DATA|0|4|1|3|1|2||| 
> |Counts|1|3|5|6|7|
> |Temp||||1||||4|

> ||0|1|2|3|4|5|6|7|
> |--|--|--|--|--|--|--|--|--|
> |DATA|0|4|1|3|1|||| 
> |Counts|1|3|4|6|7|
> |Temp||||1|2|||4|

> ||0|1|2|3|4|5|6|7|
> |--|--|--|--|--|--|--|--|--|
> |DATA|0|4|1|3||||| 
> |Counts|1|2|4|6|7|
> |Temp|||1|1|2|||4|

> ||0|1|2|3|4|5|6|7|
> |--|--|--|--|--|--|--|--|--|
> |DATA|0|4|1|||||| 
> |Counts|1|2|4|5|7|
> |Temp|||1|1|2|3||4|

> ||0|1|2|3|4|5|6|7|
> |--|--|--|--|--|--|--|--|--|
> |DATA|0|4||||||| 
> |Counts|1|1|4|5|7|
> |Temp||1|1|1|2|3||4|

> ||0|1|2|3|4|5|6|7|
> |--|--|--|--|--|--|--|--|--|
> |DATA|0|||||||| 
> |Counts|1|1|4|5|6|
> |Temp||1|1|1|2|3|4|4|

> ||0|1|2|3|4|5|6|7|
> |--|--|--|--|--|--|--|--|--|
> |DATA||||||||| 
> |Counts|0|1|4|5|6|
> |Temp|0|1|1|1|2|3|4|4|

---

### <b> ⅲ. 카운팅 정렬 알고리즘</b>
>```python
>def Counting_sort(A,k):
># A: 입력 배열
># B: 정렬된 비열
># C: 카운트 배열
># k: 최댓값
>   
>   n = len(A)
>   B = [0]*n 
>   C = [0]*(k+1) # 0 ~ k
>   
>   for i in range(0,n):
>       C[A[i]] += 1
>   
>   for i in range(1,len(C)):
>       C[i] += C[i-1]
>   
>   for i in range(n-1, -1, -1):
>       C[A[i]] -= 1
>       B[C[A[i]]] = A[i]
>   
>   return B
>```

<br><br>



## <b>Ⅴ. 완전 검색(Exaustiv Search)</b>

---

### <b> ⅰ. 완전 검색이란?</b>
완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다.  

Brute-force 혹은 generate-and-test 기법이라고도 불리운다.  

모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.  

일반적으로 경우의 수가 상대적으로 작을 때 유용하다.  

---

### <b> ⅱ. 완전 검색으로 시작하라</b>
모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률은 적음  

우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선에 힘쓰는 것이 바람직하다.

---

### <b> ⅲ. 순열의 특성</b>
서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열한 것  
서로 다른 n개 중 r개를 택하는 순열의 표현
- nPr = n!/r! = n*(n-1)*(n-2)*....*(n-r+1)

---

### <b> ⅳ. 순열 생성 알고리즘</b>
>```python
>for i in range(1,4):
>    for j in range(1,4):
>       if i != j:
>           for k in range(1,4):
>               if k != i and k != j:
>                   print(i,j,k)
>
>```

<br><br>



## <b> Ⅵ. 탐욕 알고리즘(Greedy)</b>

---

### <b> ⅰ. 탐욕 알고리즘이란?</b>
최적해를 구하는 데 사용되는 근시안적인 방법  

여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을  
선택해 나가는 방식으로 진행하여 최종적인 해답에 도달  

각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만,  
그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장 x  

일반적으로, 머릿속에 떠오르는 생각을 검증없이 바로 구현하면 Greedy가 됨

---

### <b> ⅰ. 탐욕 알고리즘 동작 과정</b>
<b>1) 해 선택</b>
- 현재 상태에서 부분 문제의 최적 해를 구함
- 이를 부분해 집합(Solution Set)에 추가  

<b>2) 실행 가능성 검사</b>
- 새로운 부분해 집합이 실행 가능한지를 확인함
- 문제의 제약 조건을 위반하지 않는지를 검사  

<b>3) 해 검사</b>
- 새로운 부분해 집합이 문제의 해가 되는지를 확인
- 전체 문제의 해가 완성되지 않았다면 1)의 해 선택부터 다시 시작 


