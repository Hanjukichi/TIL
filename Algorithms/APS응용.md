# <b>APS응용</b>
<br><br>

## <b>Ⅰ. 복잡도분석</b>

---

### <b>ⅰ. 알고리즘에 대해</b>
<br>

#### 1. 알고리즘이란?

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법  
- 주로 컴퓨터 용어로 쓰임  
- 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법  
<br>

#### <b>2. 알고리즘의 효율  </b>

공간적 효율성
- 연산량 대비 얼마나 적은 메모리 공간을 요하는가  

시간적 효율성
- 연산량 대비 얼마나 적은 시간을 요하는가  

복잡도
- 효율성을 뒤집어 표현한 것
- 복잡도가 높을수록 효율성은 저하됨  
<br>

---

### <b>ⅱ. 시간 복잡도</b>
<br>

#### <b>1. 시간적 복잡도 분석</b>
하드웨어 환경에 따라 처리시간이 달라짐
- 입출력 장비의 성능, 공유 여부
- 부동소수 처리 프로세서 존재유무, 나눗셈 가속기능 유무  

소프트웨어 환경에 따라 처리시간이 달라짐  
- 프로그램 언어의 종류
- 운영체제, 컴파일러 종류  

환경적 차이로 분석 난이도 상승  
<br>

#### <b>2. 효율적 알고리즘의 필요성</b>

|O(n^2)|1천|1백만|10억|
|---|---|---|---|
|PC|<1초|2시간|300년|
|PC|<1초|1초|주일|

|O(nlog(n))|1천|1백만|10억|
|---|---|---|---|
|O(n^2)|<1초|<1초|5초|
|O(n^2)|<1초|<1초|<1초|

효율적 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있음  

값비싼 H/W 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적  
<br>

#### <b>3. 복잡도의 점근적 표기</b>

시간 복잡도는 입력크기에 대한 함수로 표기  
- 여러 개의 항을 가진 다항식  

단순한 함수로 표현하기 위해 점근적 표기를 사용  

입력 크기 n이 무한대로 커질때의 복잡도를 위한 표기법
- Big-Oh 표기법
- Big-Omega 표기법
- Big-Theta 표기법  
<br>

#### <b>3. O(Big-Oh) 표기</b>

복잡도의 점근적 상한을 나타냄  

가장 높은 차수를 계수를 없애고 나타냄
- 2n^2 + 2n →  O(n^2)  
- n^2에 비례하는 알고리즘이라고 표현  
<br>

#### <b>4. Ω(Big-Omega) 표기</b>

복잡도의 점근적 하한을 나타냄  
- 2n^2 + 2n →  O(n^2)  
- n이 증가함에 따라 f(n)이 cn^2보다 작을 수 없다라는 의미
- 최소한 이만한 시간은 걸린다라고 표현  

O-표기와 마찬가지로 복잡도 다항식의 최고차항만 계수없이 취함  
<br>

#### <b>5. θ(Big-Theta) 표기</b>

O나 Ω와 같은 경우에 사용  
- 2n^2 + 2n →  θ(n^2) 
- f(n)은 n이 증가함에 따라 n^2과 등일한 증가율을 가짐  
<br>

#### <b>6. 자주 사용하는 O-표기</b>

- O(1) : 상수 시간
- O(log(n)) : 로그(대수) 시간
- O(n) : 선형 시간
- O(nlog(n)) : 로그 선형 시간
- O(n^2) : 제곱 시간
- O(n^3) : 세제곱 시간
- O(2n) : 지수 시간  

<br><br>

## <b>Ⅱ. 표준 입출력 방법</b>

---

### <b>ⅱ. 입력</b>
<br>

`input()`
- Raw 값의 입력
- 입력값을 문자열로 취급  

`eval(input())`
- Evaluatied된 값 입력
- 받은 입력값을 평가된 데이터형으로 취급  
<br>

### <b>ⅱ. 출력</b>
<br>

#### <b>1. 표준 출력 함수</b>

`print()`
- 표준 출력 함수
- 출력 값의 마지막에 개행 문자 포함  

`print('a', end='')`
- 마지막 개행문자 제외 

`print('%d' %number)`
- formatting된 출력  
<br>

#### <b>2. 파일 내용을 읽어는 방법</b>

```python
import sys
sys.stdin = open('a.txt', 'r')
```

<br><br>

## <b>Ⅲ. 비트 연산</b>

---

### <b>ⅰ. 비트 연산자</b>
<br>

`&`
- 비트 단위로 AND 연산

`|`
- 비트 단위로 OR 연산

`^`
- 비트 단위로 XOR 연산  

`~`
- 단항 연산자로서 피연산자의 모든 비트를 반전  

`<<`
- 피연산자의 비트열을 왼쪽으로 이동

`>>`
- 피연산자의 비트열을 오른쪽으로 이동

---

### <b>ⅱ. 비트 연산</b>
<br>

#### <b>1<<n</b>
- 2n의 값을 가짐
- 원소가 n개일 경우의 모든 부분집합의 수를 의미  

#### <b>i&(1<<j)</b>
- 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미

---

### <b>ⅲ. 비트 연산 예재</b>
<br>



>```python
>def bit_print(i):
>   output = ""
>   for j in range(7,-1,-1):
>       output += "1" if i & (1<<j) else "0"
>   print ("output")
>
>for i in range(-5, 6):
>   print("%3d = " %i, end = '')
>   bit_print(i)
>
># 결과값
>'''
>-5 = 11111011
>-4 = 11111100
>-3 = 11111101
>-2 = 11111110
>-1 = 11111111
>0 = 00000000
>1 = 00000001
>2 = 00000010
>3 = 00000011
>4 = 00000100
>5 = 00000101
>'''
>```

---

### <b>ⅳ. 엔디안(Endianness)</b>
<br>

#### <b>엔디안이란?</b>

- 메모리 같은 1차원 공간에 여러 개의 연속된 대상을 배열하는 방법  
- HW 아키텍처마다 다름  
- 크게 두 가지로 나뉨
    - 빅 엔디안: 보통 큰단위가 앞에 나옴. 네트워크
    - 리틀 엔디안: 작은 단위가 앞에 나옴. 데스크탑

종류|0x1234의 표현|0x12345678의 표현
---|---|---
빅엔디안|12 34|12 34 56 78
리틀엔디안|34 12|78 56 34 12

#### <b>엔디안 확인 코드</b>

>```python
>import sys
>print(sys.byteorder)
>```

<br><br>

## <b>Ⅳ. 진수</b>

---

### <b>ⅰ. 컴퓨터의 음의 정수 표현</b>
<br>

#### <b>1의 보수</b>

부호 비트를 제외한 나머지 비트들을 변환  
0을 1으로 1을 0으로  

1의 보수 표현
- -6 : 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 (부호의 절대값)
- -6 : 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1

#### <b>2의 보수</b>

1의 보수 방법으로 표현된 값의 최하위 비트에 1을 더함  

2의 보수 표현
- -6 : 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0  


<br><br>

## <b>Ⅴ. 실수</b>

---

### <b>ⅰ. 실수의 표현</b>
<br>

컴퓨터는 실수 표현을 위해 부동 소수점 표기법을 사용  

부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식  

    1001.0011 > 1.0010011 * 2^3


---

### <b>ⅱ. 실수 저장 형식</b>
<br>

단정수 실수(32비트)
- 부호 1비트 | 지수 8비트 | 가수 23비트

배정도 실수(64비트)
- 부호 1비트 | 지수 11비트 | 가수 52비트

가수부
- 실수의 유효 자릿수들을 부호화된 구정 소수점으로 표현

지수부
- 실제 소수점의 위치를 지수 승으로 표현

---

### <b>ⅲ. 단정도 실수</b>
<br>

#### <b>1. 가수 부분</b>
- 정수부의 첫 번째 자리가 1이 되도록 오른쪽을 시프트
- 소수점 이하를 23비트로 만듦
- 소수점 이하만을 가수 부분에 저장
- 지수 부분은 시프트 한 자릿수 만큼 증가 또는 감소  


#### <b>2. 지수 부분</b>
- 지수부에는 8비트가 배정
- 음수 값을 나타낼 수 있어야 하므로 익세스 표현법 사용
    - 익세스 표현법: 지수부의 값을 반으로 나누어 그 값을 0으로 간주 > 음수지수와 양수지수 표현  

#### <b>1001.0011 단정도 실수로 표현</b>

    0 10000010 00100110000000000000000  


---

### <b>ⅳ. 컴퓨터 실수 표현의 특징</b>
<br>

컴퓨터는 실수를 근사적으로 표현
- 이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근사값으로 저장
- 이 때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져옴  

파이썬에서의 실수 표현 범위
- 파이썬에서는 내부적으로 더 많은 비트를 사용
- 훨씬 넓은 범위의 실수를 표현 가능
- 최대 표현 : 1.8 * 10^308 (이 이상은 inf)
- 최소 표현 : 5.0 10^(-324) (이 이상은 0)


