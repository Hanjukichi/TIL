# <b>트리</b>
<br><br>

## <b>Ⅰ. 트리란?</b>

---

### <b>ⅰ. 트리의 개념</b>
<br>

비선형 구조  

원소들 간에 1 : n 관계를 가지는 자료 구조  

원소들 간에 계층과계를 가지는 계층형 자료구조  

상위 원소에서 하위 원소로 내려가면서 확장되는 트리모양의 구조  

---

### <b>ⅱ. 트리의 정의</b>
<br>

한 개 이상의 노드로 이루어진 유한 집합
- 루트(root): 최상위 노드
- 나머지 노드들은 분리 집합 T1, ... , Tn 으로 분리  

분리집합(T1 ~ Tn)
- 각각 하나의 트리가 됨 (재귀적 정의)
- 루트의 부트리(subtree) 라고 함  

---

### <b>ⅲ. 트리 용어 정리</b>
<br>

노드(node) : 트리의 원소  

간선(edge) : 노드를 연결하는 선, 부모 노드와 자식 노드를 연결  

루트 노드(root node) : 트리의 시작 노드  

형제 노드(sibling node) : 같은 부모 노드의 자식 노드들  

조상 노드 : 간선을 따라 루트 노드까지 이르는 경로의 모든 노드들  

서브 트리(subtree) : 부모 노드와 연결된 간선을 끊으면 생성되는 트리  

자손 노드 : 서브 트리에 있는 하위 레벨의 노드들  

차수(degree):  
- 노드의 차수 : 노드에 연결된 자식 노드의 수
- 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값
- 단말 노드(리프 노드) : 차수가 0인 노드  

높이:
- 노드의 높이 : 루트에서 노드에 이르는 간선의 수 (노드의 레벨)
- 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값 (최대 레벨)  

<br><br>

## <b>Ⅱ. 이진 트리(Binary Tree)</b>

---

### <b>ⅰ. 이진 트리란?</b>
<br>

모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리  

각 노드가 자식 노드를 최대한 2개까지만 가질 수 있는 트리
- 왼쪽 자식 노드 : left child node
- 오른쪽 자식 노드 : right child node  

레벨 i에서의 노드의 최대 개수는 2^i개  

높이가 h인 이진 트리
- 최소 노드 수 : h+1
- 최대 노드 수 : 2^(h+1) - 1

---

### <b>ⅱ. 이진 트리의 종류</b>
<br>

<b>포화 이진 트리(Full Binary Tree)</b>  
- 모든 레벨에 노드가 포화 상태로 차있는 트리
- 높이가 h일 때, 최대 노드의 개수: 2^(h+1) - 1
- 루트를 1번으로 하여 2^(h+1)-1 까지 정해진 위치에 대한 노드 번호 부여  

<b>완전 이진 트리(Complete Binary Tree)</b>  
- 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리
- 즉, 최대 높이-1 까지는 포화 이진 트리
- 최대 높이에선 순서대로 n까지 존재

<b>편향 이진 트리(Skewed Binary Tree)</b>  
- 최소 개수의 노드만 가짐
- 한쪽 방향의 자식 노드만을 가짐
    - 왼쪽 편향과 오른쪽 편향


---

### <b>ⅲ. 이진 트리의 순회</b>
<br>  

<b>트리의 순회</b>
- 트리의 각 노드를 중복되지 않게 전부 방문하는 것
- 트리는 비선형 구조라 선후 연결 관계를 알 수 없음
- 특별한 방법이 필요


<b>3가지 기본 순회방법</b>
- 전위순회(preorder traversal) - VLR
    - 부모 노드 방문 후, 자식 노드를 좌,우 순서로 방문
- 중위순회(inorder traversal) - LVR
    - 왼쪽 자식 노드, 부모 노드, 오른쪽 자식 노드 순으로 방문
- 중위순회(postorder traversal) - LRV
    - 자식 노드를 좌우 순서로 방문 후, 부모 노드 방문  

<b>전위 순회 알고리즘</b>
>``` python
>def preorder_traverse(T):
>   if T:
>       visit(T)  # T에서 수행할 행동
>       preorder_traverse(T.left)
>       preorder_traverse(T.right)
>```

<b>중위 순회 알고리즘</b>
>``` python
>def inorder_traverse(T):
>   if T:
>       preorder_traverse(T.left)
>       visit(T)  # T에서 수행할 행동
>       preorder_traverse(T.right)
>```

<b>후위 순회 알고리즘</b>
>``` python
>def inorder_traverse(T):
>   if T:
>       preorder_traverse(T.left)
>       preorder_traverse(T.right)
>       visit(T)  # T에서 수행할 행동
>```
<br><br>

## <b>Ⅲ. 이진 트리의 구현</b>

---

### <b>ⅰ. 배열의 활용한 표현</b>
<br>

<b>노드 번호의 성질</b>
- 노드 번호가 i 인 노드의 부모 노드 번호 : i // 2  
- 노드 번호가 i 인 노드의 왼쪽 자식 노드 번호 : i * 2
- 노드 번호가 i 인 노드의 오른쪽 자식 노드 번호 : i * 2 + 1
- 레벨 n의 노드 번호 시작 번호 : 2 ^ n

<b>완전 이진 트리의 표현</b>
|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
||A|B|C|D|E|F|G|H|I|J||||||

<b>왼쪽 편향 이진 트리의 표현</b>
|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
||A|B||C||||D||||||||

<b>오른쪽 편향 이진 트리의 표현</b>
|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
||A||B||||C||||||||D|


---

### <b>ⅱ. 이진 트리의 저장</b>
<br>

간선 개수(N) : 4  
1 2 1 3 3 4 3 5 : 부모 자식 관계 (부모 자식 순서)

부모 번호를 인덱스로 자식 번호를 저장
|0|1|2|3|4|5|
|---|---|---|---|---|---|
|0|2|0|4|0|0|
|0|3|0|5|0|0|  

자식 번호를 인덱스로 부모 번호를 저장
|0|1|2|3|4|5|
|---|---|---|---|---|---|
|0|0|1|1|3|3|

---

### <b>ⅲ. 루트 찾기, 조상 찾기</b>
<br>

자식 번호를 인덱스로 부모 번호를 저장한 배열을 활용  

<b>조상 찾기</b>
>```python
># 루트 노드는 부모값이 빈값 or 0 
>while arr[nod] != 0:
>   nod = arr[nod]
>   anc.append(nod)  # anc : 조상 목록 
>root = nod
>```

---

### <b>ⅳ. 연결리스트</b>
<br>

<b>배열 활용의 단점</b>
- 편향 이진 트리의 경우 사용하지 않는 배열 원소에 대한 메모리 공간 낭비
- 새로운 노드의 삽입 혹은 삭제의 경우 배열의 크기 변경이 어려움  

이러한 단점 보완을 위해 연결리스트를 이용하여 트리 표현 가능  

연결 자료구조를 이용한 이진트리의 표현
- 최대 2개의 자식노드를 보유
- 일정한 구조의 단순 연결 리스트 노드를 사용하여 구현
- ex) `[왼쪽 자식 주소, root, 오른쪽 자식 주소]`  

<br><br>

## <b>Ⅳ. 이진  탐색 트리</b>

---

### <b>ⅰ. 이진 탐색 트리란?</b>
<br>

탐색 작업을 효율적으로 하기 위한 자료구조  

모든 원소는 서로 다른 유일한 키를 가짐  

key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)  

왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리다.  

중위 순회하면 오른차순으로 정렬된 값을 얻을 수 있다.  

---

### <b>ⅱ. 이진 탐색 트리의 탐색</b>
<br>

루트에서 시작  

탐색할 키 값 x를 루트 노드의 카 값과 비교
- x == 루트 노드: 원하는 원소를 찾았으므로 탐색 성공
- x < 루트 노드: 루트 노드의 왼쪽 서브트리에 대한 탐색연산 수행
- x > 루트 노드: 루트 노드의 오른쪽 서브트리에 대해 탐색연산 수행  

서브 트리에 대해서 순환적으로 탐색 연산을 반복

---

### <b>ⅲ. 이진 탐색 트리의 삽입</b>
<br>

탐색 연산을 수행
- 삽입할 원소와 같은 원소가 트리에 있으면 삽입할 수 없음
- 탐색에서 탐색 실패가 결정되는 위치가 삽입위치가 됨  

탐색 실패한 위치에 원소를 삽입

---

### <b>ⅳ. 이진 탐색 트리의 성능</b>
<br>

탐색, 삽입, 삭제 시간은 트리의 높이만큼 시간이 걸림
- O(h)
- h : BST의 깊이  

평균의 경우
- 이진 트리가 균형적으로 생성되어 있는 경우
- O(log n)  

최악의 경우
- 한족으로 치우친 경사 이진트리의 경우
- O(n)
- 순차 탐색과 시간복잡도가 같음

---

### <b>ⅴ. 검색 알고리즘의 비교</b>
<br>

배열에서의 순차 검색 : O(N)  

정렬된 배열에서의 이진탐색: O(N)  

정렬된 배열에서의 이진탐색: O(logN)
- 고정 배열 크기와 삽입, 삭제시 추가 연산 필요  

이진 탐색 트리에서의 평균: O(logN)
- 최악의 경우: O(N)
- 완전 이진 트리 또는 균형트리로 바꿀 수 있다면 최악의 경우 삭제 가능
    - 새로운 원소를 삽입할 때 삽입시간 감소 가능
    - 평균과 최악의 시간이 같음(O(log n))  

해쉬 검색: O(1)
- 추가 저장 공간이 필요

<br><br>

## <b>Ⅴ. 힙(heap)</b>

---

### <b>ⅰ. 힙이란?</b>
<br>

완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해서 만든 자료구조  

최대 힙(max heap)
- 키값이 가장 큰 노드를 찾기 위한 완전 이진 트리  
- 부모노드의 키값 > 자식 노드의 키 값
- 루트 노드: 키 값이 가장 큰 노드  

최소 힙(min heap)
- 키값이 가장 작은 노드를 차ㅏㅈ기 위한 완전 이진 트리  
- 부모노드의 키값 < 자식노드의 키값
- 루트 노드: 키값이 가장 작은 노드