# <b>스택1</b>
<br><br>

## <b>Ⅰ. 스택</b>

---

### <b>ⅰ. 스택의 특성</b>
<br>

선형 구조를 가짐
- 선형 구조 : 자료 간의 관계가 1대 1의 관계
- 비선형구조 : 자료 간의 관계가 1대N의 관계를 가짐  

스택에 자료를 삽입하거나 자료를 꺼낼 수 있음  

후입선출(LIFO, Last-In-First_Out)
- 마지막에 삽입한 자료를 가장 먼저 꺼냄

---

### <b>ⅱ. 필요한 자료구조와 연산</b>
<br>

자료구조 : 자료를 선형으로 저장할 저장소  
- 배열을 사용할 수 있음
- 저장소 자체를 스택이라 부르기도 함  
- 스택에서 마지막에 삽입된 원소의 위치를 top이라함  

연산
- 삽입 : 저장소에 자료를 저장. push라 부름
- 삭제 : 저장소에서 자료를 꺼냄. pop이라 부름
- 공백 확인 : isEmpty
- 스택의 top에 있는 원소 반환. peek이라 부름

---

### <b>ⅲ. 스택의 삽입/삭제 과정</b>
<br>

<b>push A</b>
top|1|2|3|4|
---|---|---|---|---|
A|||||

<b>push B</b>
0|top|2|3|4|
---|---|---|---|---|
A|B||||

<b>push C</b>
0|1|top|3|4|
---|---|---|---|---|
A|B|C|||

<b>pop C</b>
0|top|2|3|4|
---|---|---|---|---|
A|B||||

---

### <b>ⅲ. 스택의 알고리즘</b>

<b>push</b>
>```python
>def push(item, size):
>   global top
>   top += 1
>   if top == size:
>       print('overflow!')
>   else:
>       stack[top] = item
>```

<b>pop</b>
>```python
>def pop():
>   global top
>   if top == -1:
>       print('underflow!')
>       return 0
>   else:
>       top -= 1
>       return stack[top+1]
>```

---

### <b>ⅳ. Function Call</b>

프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리  

- 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료 후 복귀
- 함수호출이 발생하면 호출한 함수 수행에 필요한 지역 변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임(stack frame)에 저장하여 시스템 스택에 삽입
- 함수 실행 종료 후 시스템 스택의 top 원소를 삭제하면서 프레임에 저장되어 있던 복귀 주소를 확인하고 복귀
- 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 스택은 공백이 됨

<br><br>

---

## <b>Ⅱ. 재귀호출</b>

---

### <b>ⅰ. 재귀 호출이란</b>
<br>

자기 자신을 호출하여 순환 수행되는 것  

작업의 특성에 따라 재귀 호출방식을 사용하면 프로그램의 크기를 줄이고 간단하게 작성  

<b>피보나치 수를 구하는 재귀 함수</b>
>```python
>def fibo(n):
>   if n < 2:
>       return n
>   else:
>       return fibo(n-1) + fibo(n-2)
>```

---

### <b>ⅱ. Memorization</b>
<br>

재귀 함수에는 엄청난 중복 호출이 존재하는 경우가 많음

<b>메모이제이션이란?</b>
- 이전에 계산한 값을 메모리에 저장
- 매번 다시 계산하지 않도록 함
- 실행속도 상승
- 동적 계획법의 핵심

<b>메모이제이션을 활용한 피보나치</b>
>```python
>def fibo1(n):
>   global memo
>   if n >= 2 and memo[n] = 0:
>       memo[n] = (fibo1(n-1) + fibo1(n-2))
>       return memo[n]
>
>memo = [0] * (n+1)
>memo[0] = 0
>memo[1] = 1
>```

---

## <b>ⅲ. DP(Dynamic Programming)</b>
<br>

최적화 문제를 해력하는 알고리즘  

먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘


<b>동적 계획을 활용한 피보나치</b>
>```python
>def fibo2(n):
>   f = [0] * (n+1)
>   f[0] = 0
>   f[1] = 1
>   for i in range(2, n+1):
>       f[i] = f[i-1] + f[i-2]
>   
>   return f[n]
>```  

메모이제이션을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 성능면에서 효율적  

재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문

<br><br>

---

## <b>Ⅲ. DFS(깊이우선탐색)</b>

---

### <b>ⅰ. 깊이 우선 탐색이란?</b>
<br>

시작 정점에서 한 방향으로 갈 수있는 경로까지 탐색  

더 이상 갈 곳이 없으면 마지막 갈림길로 회귀  

회귀 지점부터 다시 갈 수 있을 만큼 탐색  

이런 식으로 모든 정점 방문하는 순회 방법  

후입 선출 구조의 스택 사용


---

### <b>ⅰ. 깊이 우선 탐색알고리즘</b>
<br>

(1) 시작 정점 v를 결정하여 방문  

(2) 정점 v에 인접한 정점 중
- 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push하고 정점 w를 방문
- w를 v로하여 다시 2) 반복
- 방분하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해 스택을 pop
- pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 2) 반복  

(3) 스택이 공백이 될 때까지 2)를 반복
